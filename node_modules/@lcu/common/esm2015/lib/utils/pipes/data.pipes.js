import { Pipe } from '@angular/core';
import { DatePipe, DecimalPipe, PercentPipe } from '@angular/common';
import { DataPipeConstants } from '../constants/data-pipe.constants';
import { TemperatureConversion } from '../conversion/temperature.conversion';
import { TimezoneConversion } from '../conversion/timezone.conversion';
/**
 * Custom transfomration pipes
 *
 * @param val value to be returned transformed
 * @param arg argument containing format string ('dd/MMM/yyyy')
 *
 * Ex.
 * // constants outside of a component need to be assigned
 * // to a local property in order to work
 *
 * const dateFmt: string = DataPipeConstants.DATE_FMT;
 * <span>{{ val | dataPipes:dateFmt }}</span>
 */
export class DataPipes {
    transform(val, arg) {
        if (!arg) {
            return val;
        }
        const format = arg.toLowerCase();
        /**
         * Return date M/d/YYYY
         */
        if (format === DataPipeConstants.PIPE_SHORTDATE) {
            const pipe = new DatePipe('en-US');
            const transformed = pipe.transform(val, DataPipeConstants.DATE_SHORTDATE);
            return transformed;
        }
        /**
         * Return date
         */
        if (format === DataPipeConstants.PIPE_DATE.toLowerCase()) {
            const pipe = new DatePipe('en-US');
            const transformed = pipe.transform(val, DataPipeConstants.DATE_FMT);
            return transformed;
        }
        /**
         * Return date MMM d, y
         */
        if (format === DataPipeConstants.PIPE_MEDIUMDATE.toLowerCase()) {
            const pipe = new DatePipe('en-US');
            const transformed = pipe.transform(val, 'MMM d, y');
            return transformed;
        }
        /**
         * Return date 'EEEE, MMMM d, y'
         */
        if (format === DataPipeConstants.PIPE_FULLDATE.toLowerCase()) {
            const pipe = new DatePipe('en-US');
            const transformed = pipe.transform(val, DataPipeConstants.DATE_FULLDATE);
            return transformed;
        }
        /**
         * Return MM/dd/yyyy hh:mm:ss a z
         */
        if (format === DataPipeConstants.DATE_TIME_ZONE_FMT.toLowerCase()) {
            const pipe = new DatePipe('en-US');
            const transformed = pipe.transform(val, DataPipeConstants.DATE_TIME_ZONE_FMT);
            const splittedString = transformed.toString().split(' ');
            splittedString[splittedString.length - 1] = TimezoneConversion.GMTTimezoneConversion(splittedString[splittedString.length - 1]);
            let newDateString = '';
            splittedString.forEach((st) => {
                if (splittedString.indexOf(st) < splittedString.length - 1) {
                    newDateString += st + ' ';
                }
                else {
                    newDateString += st;
                }
            });
            return newDateString;
        }
        /**
         * Return date from epoch val
         */
        if (format === DataPipeConstants.PIPE_EPOCH.toLowerCase()) {
            const pipe = new DatePipe('en-US');
            const transformed = pipe.transform(val * 1000, DataPipeConstants.DATE_DAY_TIME);
            return transformed;
        }
        /**
         * Return number with decimal
         */
        if (format === DataPipeConstants.PIPE_NUMBER.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            const transformed = pipe.transform(val, '1.0-0');
            return transformed;
        }
        /**
         * Return return number with mph appended
         */
        if (format === DataPipeConstants.PIPE_MPH.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            const transformed = pipe.transform(val, '1.0-0');
            return transformed + ' mph';
        }
        /**
         * Return percentage
         */
        if (format === DataPipeConstants.PIPE_PERCENTAGE.toLowerCase()) {
            const pipe = new PercentPipe('en-US');
            const transformed = pipe.transform(val);
            return transformed;
        }
        /**
         * Return percentage
         */
        if (format === DataPipeConstants.PIPE_PERCENTAGE_DECIMAL.toLowerCase()) {
            const pipe = new PercentPipe('en-US');
            const transformed = pipe.transform(val, '2.2-2');
            return transformed;
        }
        /**
         * Return percentage with two decimals
         */
        if (format === DataPipeConstants.PIPE_DECIMAL_TWO.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            const transformed = pipe.transform(val, '1.2-2');
            return transformed;
        }
        /**
         * Return percentage with four decimals
         */
        if (format === DataPipeConstants.PIPE_DECIMAL_FOUR.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            const transformed = pipe.transform(val, '1.4-4');
            return transformed;
        }
        /**
         * Return temperature in fahrenheit, append °F
         */
        if (format === DataPipeConstants.PIPE_TEMP_FAHRENHEIT.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            // const temperature = (val * 32) + 1.8;
            const transformed = pipe.transform(val, '1.0-0');
            return transformed + ' °F';
        }
        /**
         * Return temperature in kelvin, append °K
         */
        if (format === DataPipeConstants.PIPE_TEMP_KELVIN.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            // const temperature = (val * 32) + 1.8;
            const temperature = TemperatureConversion.FahrenheitToKelvin(val);
            const transformed = pipe.transform(temperature, '1.0-0');
            return transformed + ' °K';
        }
        /**
         * Return temperature in celsius, append °C
         */
        if (format === DataPipeConstants.PIPE_TEMP_CELSIUS.toLowerCase()) {
            const pipe = new DecimalPipe('en-US');
            const temperature = TemperatureConversion.FahrenheitToCelsius(val);
            const transformed = pipe.transform(temperature, '1.0-0');
            return transformed + ' °C';
        }
        /**
         * retrun the string sliced down to 50
         */
        if (format === DataPipeConstants.PIPE_STRING_SLICE_FIFTY.toLowerCase()) {
            return val.slice(0, 50) + '...';
        }
        /**
         * retrun the string sliced down to 70
         */
        if (format === DataPipeConstants.PIPE_STRING_SLICE_SEVENTY.toLowerCase()) {
            return val.slice(0, 70) + '...';
        }
        /**
         * retrun the string sliced down to 100
         */
        if (format === DataPipeConstants.PIPE_STRING_SLICE_HUNDRED.toLowerCase()) {
            return val.slice(0, 100) + '...';
        }
        /**
         * Return password visibility
         */
        if (format === DataPipeConstants.PIPE_PASSWORD.toLowerCase()) {
            return '•'.repeat(val.length);
        }
        /**
         * IF none of the above work, return the original val
         */
        return val;
    }
}
DataPipes.decorators = [
    { type: Pipe, args: [{
                name: 'dataPipes'
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS5waXBlcy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BsY3UvY29tbW9uLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL3BpcGVzL2RhdGEucGlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDckUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDckUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDN0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFPdkU7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxPQUFPLFNBQVM7SUFFcEIsU0FBUyxDQUFDLEdBQVEsRUFBRyxHQUFZO1FBRS9CLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUixPQUFPLEdBQUcsQ0FBQztTQUNaO1FBRUQsTUFBTSxNQUFNLEdBQVcsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXpDOztXQUVHO1FBQ0gsSUFBSSxNQUFNLEtBQUssaUJBQWlCLENBQUMsY0FBYyxFQUFFO1lBRS9DLE1BQU0sSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRW5DLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBRTFFLE9BQU8sV0FBVyxDQUFDO1NBQ3BCO1FBRUQ7O1dBRUc7UUFDSCxJQUFJLE1BQU0sS0FBSyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFFeEQsTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFbkMsTUFBTSxXQUFXLEdBQUcsSUFBSSxD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T0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUM7U0FDakM7UUFFRDs7V0FFRztRQUVILElBQUksTUFBTSxLQUFLLGlCQUFpQixDQUFDLHlCQUF5QixDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQ3hFLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ2pDO1FBRUQ7O1dBRUc7UUFFSCxJQUFJLE1BQU0sS0FBSyxpQkFBaUIsQ0FBQyx5QkFBeUIsQ0FBQyxXQUFXLEVBQUUsRUFBRTtZQUN4RSxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUNsQztRQUVEOztXQUVHO1FBQ0gsSUFBSSxNQUFNLEtBQUssaUJBQWlCLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQzVELE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDL0I7UUFFRDs7V0FFRztRQUNILE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQzs7O1lBdlFGLElBQUksU0FBQztnQkFDSixJQUFJLEVBQUUsV0FBVzthQUNsQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRGF0ZVBpcGUsIERlY2ltYWxQaXBlLCBQZXJjZW50UGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IERhdGFQaXBlQ29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzL2RhdGEtcGlwZS5jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBUZW1wZXJhdHVyZUNvbnZlcnNpb24gfSBmcm9tICcuLi9jb252ZXJzaW9uL3RlbXBlcmF0dXJlLmNvbnZlcnNpb24nO1xyXG5pbXBvcnQgeyBUaW1lem9uZUNvbnZlcnNpb24gfSBmcm9tICcuLi9jb252ZXJzaW9uL3RpbWV6b25lLmNvbnZlcnNpb24nO1xyXG5cclxuXHJcbkBQaXBlKHtcclxuICBuYW1lOiAnZGF0YVBpcGVzJ1xyXG59KVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSB0cmFuc2ZvbXJhdGlvbiBwaXBlc1xyXG4gKlxyXG4gKiBAcGFyYW0gdmFsIHZhbHVlIHRvIGJlIHJldHVybmVkIHRyYW5zZm9ybWVkXHJcbiAqIEBwYXJhbSBhcmcgYXJndW1lbnQgY29udGFpbmluZyBmb3JtYXQgc3RyaW5nICgnZGQvTU1NL3l5eXknKVxyXG4gKlxyXG4gKiBFeC5cclxuICogLy8gY29uc3RhbnRzIG91dHNpZGUgb2YgYSBjb21wb25lbnQgbmVlZCB0byBiZSBhc3NpZ25lZFxyXG4gKiAvLyB0byBhIGxvY2FsIHByb3BlcnR5IGluIG9yZGVyIHRvIHdvcmtcclxuICpcclxuICogY29uc3QgZGF0ZUZtdDogc3RyaW5nID0gRGF0YVBpcGVDb25zdGFudHMuREFURV9GTVQ7XHJcbiAqIDxzcGFuPnt7IHZhbCB8IGRhdGFQaXBlczpkYXRlRm10IH19PC9zcGFuPlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERhdGFQaXBlcyBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG5cclxuICB0cmFuc2Zvcm0odmFsOiBhbnkgLCBhcmc/OiBzdHJpbmcpOiBhbnkge1xyXG5cclxuICAgIGlmICghYXJnKSB7XHJcbiAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZm9ybWF0OiBzdHJpbmcgPSBhcmcudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBkYXRlIE0vZC9ZWVlZXHJcbiAgICAgKi9cclxuICAgIGlmIChmb3JtYXQgPT09IERhdGFQaXBlQ29uc3RhbnRzLlBJUEVfU0hPUlREQVRFKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERhdGVQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsIERhdGFQaXBlQ29uc3RhbnRzLkRBVEVfU0hPUlREQVRFKTtcclxuXHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBkYXRlXHJcbiAgICAgKi9cclxuICAgIGlmIChmb3JtYXQgPT09IERhdGFQaXBlQ29uc3RhbnRzLlBJUEVfREFURS50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERhdGVQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsIERhdGFQaXBlQ29uc3RhbnRzLkRBVEVfRk1UKTtcclxuXHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBkYXRlIE1NTSBkLCB5XHJcbiAgICAgKi9cclxuICAgIGlmIChmb3JtYXQgPT09IERhdGFQaXBlQ29uc3RhbnRzLlBJUEVfTUVESVVNREFURS50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERhdGVQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsICdNTU0gZCwgeScpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGRhdGUgJ0VFRUUsIE1NTU0gZCwgeSdcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9GVUxMREFURS50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERhdGVQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsIERhdGFQaXBlQ29uc3RhbnRzLkRBVEVfRlVMTERBVEUpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gTU0vZGQveXl5eSBoaDptbTpzcyBhIHpcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuREFURV9USU1FX1pPTkVfRk1ULnRvTG93ZXJDYXNlKCkpIHtcclxuXHJcbiAgICAgIGNvbnN0IHBpcGUgPSBuZXcgRGF0ZVBpcGUoJ2VuLVVTJyk7XHJcblxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHBpcGUudHJhbnNmb3JtKHZhbCwgRGF0YVBpcGVDb25zdGFudHMuREFURV9USU1FX1pPTkVfRk1UKTtcclxuXHJcbiAgICAgIGNvbnN0IHNwbGl0dGVkU3RyaW5nID0gdHJhbnNmb3JtZWQudG9TdHJpbmcoKS5zcGxpdCgnICcpO1xyXG5cclxuICAgICAgc3BsaXR0ZWRTdHJpbmdbc3BsaXR0ZWRTdHJpbmcubGVuZ3RoIC0gMSBdID0gVGltZXpvbmVDb252ZXJzaW9uLkdNVFRpbWV6b25lQ29udmVyc2lvbihzcGxpdHRlZFN0cmluZ1tzcGxpdHRlZFN0cmluZy5sZW5ndGgtMV0pO1xyXG5cclxuICAgICAgbGV0IG5ld0RhdGVTdHJpbmc6IHN0cmluZyA9ICcnO1xyXG5cclxuICAgICAgc3BsaXR0ZWRTdHJpbmcuZm9yRWFjaCgoc3Q6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGlmIChzcGxpdHRlZFN0cmluZy5pbmRleE9mKHN0KSA8IHNwbGl0dGVkU3RyaW5nLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIG5ld0RhdGVTdHJpbmcgKz0gc3QgKyAnICc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld0RhdGVTdHJpbmcgKz0gc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBuZXdEYXRlU3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGRhdGUgZnJvbSBlcG9jaCB2YWxcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9FUE9DSC50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERhdGVQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwgKiAxMDAwLCBEYXRhUGlwZUNvbnN0YW50cy5EQVRFX0RBWV9USU1FKTtcclxuXHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBudW1iZXIgd2l0aCBkZWNpbWFsXHJcbiAgICAgKi9cclxuICAgIGlmIChmb3JtYXQgPT09IERhdGFQaXBlQ29uc3RhbnRzLlBJUEVfTlVNQkVSLnRvTG93ZXJDYXNlKCkpIHtcclxuXHJcbiAgICAgIGNvbnN0IHBpcGUgPSBuZXcgRGVjaW1hbFBpcGUoJ2VuLVVTJyk7XHJcblxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHBpcGUudHJhbnNmb3JtKHZhbCwgJzEuMC0wJyk7XHJcblxyXG4gICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gcmV0dXJuIG51bWJlciB3aXRoIG1waCBhcHBlbmRlZFxyXG4gICAgICovXHJcbiAgICBpZiAoZm9ybWF0ID09PSBEYXRhUGlwZUNvbnN0YW50cy5QSVBFX01QSC50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERlY2ltYWxQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsICcxLjAtMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkICsgJyBtcGgnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHBlcmNlbnRhZ2VcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9QRVJDRU5UQUdFLnRvTG93ZXJDYXNlKCkpIHtcclxuXHJcbiAgICAgIGNvbnN0IHBpcGUgPSBuZXcgUGVyY2VudFBpcGUoJ2VuLVVTJyk7XHJcblxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHBpcGUudHJhbnNmb3JtKHZhbCk7XHJcblxyXG4gICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gcGVyY2VudGFnZVxyXG4gICAgICovXHJcbiAgICBpZiAoZm9ybWF0ID09PSBEYXRhUGlwZUNvbnN0YW50cy5QSVBFX1BFUkNFTlRBR0VfREVDSU1BTC50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IFBlcmNlbnRQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsICcyLjItMicpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHBlcmNlbnRhZ2Ugd2l0aCB0d28gZGVjaW1hbHNcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9ERUNJTUFMX1RXTy50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERlY2ltYWxQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsICcxLjItMicpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHBlcmNlbnRhZ2Ugd2l0aCBmb3VyIGRlY2ltYWxzXHJcbiAgICAgKi9cclxuICAgIGlmIChmb3JtYXQgPT09IERhdGFQaXBlQ29uc3RhbnRzLlBJUEVfREVDSU1BTF9GT1VSLnRvTG93ZXJDYXNlKCkpIHtcclxuXHJcbiAgICAgIGNvbnN0IHBpcGUgPSBuZXcgRGVjaW1hbFBpcGUoJ2VuLVVTJyk7XHJcblxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHBpcGUudHJhbnNmb3JtKHZhbCwgJzEuNC00Jyk7XHJcblxyXG4gICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGVtcGVyYXR1cmUgaW4gZmFocmVuaGVpdCwgYXBwZW5kIMKwRlxyXG4gICAgICovXHJcbiAgICBpZiAoZm9ybWF0ID09PSBEYXRhUGlwZUNvbnN0YW50cy5QSVBFX1RFTVBfRkFIUkVOSEVJVC50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICBjb25zdCBwaXBlID0gbmV3IERlY2ltYWxQaXBlKCdlbi1VUycpO1xyXG5cclxuICAgICAgLy8gY29uc3QgdGVtcGVyYXR1cmUgPSAodmFsICogMzIpICsgMS44O1xyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBwaXBlLnRyYW5zZm9ybSh2YWwsICcxLjAtMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkICsgJyDCsEYnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRlbXBlcmF0dXJlIGluIGtlbHZpbiwgYXBwZW5kIMKwS1xyXG4gICAgICovXHJcbiAgICBpZiAoZm9ybWF0ID09PSBEYXRhUGlwZUNvbnN0YW50cy5QSVBFX1RFTVBfS0VMVklOLnRvTG93ZXJDYXNlKCkpIHtcclxuXHJcbiAgICAgIGNvbnN0IHBpcGUgPSBuZXcgRGVjaW1hbFBpcGUoJ2VuLVVTJyk7XHJcblxyXG4gICAgICAvLyBjb25zdCB0ZW1wZXJhdHVyZSA9ICh2YWwgKiAzMikgKyAxLjg7XHJcblxyXG4gICAgICBjb25zdCB0ZW1wZXJhdHVyZSA9IFRlbXBlcmF0dXJlQ29udmVyc2lvbi5GYWhyZW5oZWl0VG9LZWx2aW4odmFsKTtcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gcGlwZS50cmFuc2Zvcm0odGVtcGVyYXR1cmUsICcxLjAtMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkICsgJyDCsEsnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRlbXBlcmF0dXJlIGluIGNlbHNpdXMsIGFwcGVuZCDCsENcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9URU1QX0NFTFNJVVMudG9Mb3dlckNhc2UoKSkge1xyXG5cclxuICAgICAgY29uc3QgcGlwZSA9IG5ldyBEZWNpbWFsUGlwZSgnZW4tVVMnKTtcclxuXHJcbiAgICAgIGNvbnN0IHRlbXBlcmF0dXJlID0gVGVtcGVyYXR1cmVDb252ZXJzaW9uLkZhaHJlbmhlaXRUb0NlbHNpdXModmFsKTtcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gcGlwZS50cmFuc2Zvcm0odGVtcGVyYXR1cmUsICcxLjAtMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkICsgJyDCsEMnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0cnVuIHRoZSBzdHJpbmcgc2xpY2VkIGRvd24gdG8gNTBcclxuICAgICAqL1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT09IERhdGFQaXBlQ29uc3RhbnRzLlBJUEVfU1RSSU5HX1NMSUNFX0ZJRlRZLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgcmV0dXJuIHZhbC5zbGljZSgwLCA1MCkgKyAnLi4uJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHJ1biB0aGUgc3RyaW5nIHNsaWNlZCBkb3duIHRvIDcwXHJcbiAgICAgKi9cclxuXHJcbiAgICBpZiAoZm9ybWF0ID09PSBEYXRhUGlwZUNvbnN0YW50cy5QSVBFX1NUUklOR19TTElDRV9TRVZFTlRZLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgcmV0dXJuIHZhbC5zbGljZSgwLCA3MCkgKyAnLi4uJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHJ1biB0aGUgc3RyaW5nIHNsaWNlZCBkb3duIHRvIDEwMFxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9TVFJJTkdfU0xJQ0VfSFVORFJFRC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgIHJldHVybiB2YWwuc2xpY2UoMCwgMTAwKSArICcuLi4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHBhc3N3b3JkIHZpc2liaWxpdHlcclxuICAgICAqL1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gRGF0YVBpcGVDb25zdGFudHMuUElQRV9QQVNTV09SRC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgIHJldHVybiAn4oCiJy5yZXBlYXQodmFsLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJRiBub25lIG9mIHRoZSBhYm92ZSB3b3JrLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbFxyXG4gICAgICovXHJcbiAgICByZXR1cm4gdmFsO1xyXG4gIH1cclxufVxyXG4iXX0=