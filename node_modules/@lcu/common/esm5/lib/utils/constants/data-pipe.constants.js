// @dynamic
/**
 * @dynamic need this because there are static memebers
 *
 * String that represent the transformed format, used
 * with DataPipes.
 *
 * Ex.
 * // constants outside of a component need to be assigned
 * // to a local property in order to work
 *
 * const dateFmt: string = DataPipeConstants.DATE_FMT;
 * <span>{{ value | dataPipes:dateFmt }}</span>
 */
var DataPipeConstants = /** @class */ (function () {
    function DataPipeConstants() {
    }
    DataPipeConstants.DATE_FMT = 'dd/MMM/yyyy';
    DataPipeConstants.DATE_SHORTDATE = 'M/d/yy';
    DataPipeConstants.DATE_MEDIUMDATE = 'MMM d, y';
    DataPipeConstants.DATE_FULLDATE = 'EEEE, MMMM d, y';
    DataPipeConstants.DATE_TIME_FMT = DataPipeConstants.DATE_FMT + " hh:mm:ss";
    DataPipeConstants.DATE_TIME_ZONE_FMT = 'MM/dd/yyyy hh:mm:ss a z';
    DataPipeConstants.DATE_DAY_TIME = 'EEE h a';
    DataPipeConstants.PIPE_DATE = 'date';
    DataPipeConstants.PIPE_SHORTDATE = 'shortdate';
    DataPipeConstants.PIPE_MEDIUMDATE = 'mediumdate';
    DataPipeConstants.PIPE_FULLDATE = 'fulldate';
    DataPipeConstants.PIPE_DECIMAL_TWO = 'decimalTwo';
    DataPipeConstants.PIPE_DECIMAL_FOUR = 'decimalfour';
    DataPipeConstants.PIPE_EPOCH = 'epoch';
    DataPipeConstants.PIPE_NUMBER = 'number';
    DataPipeConstants.PIPE_PERCENTAGE = 'percentage';
    DataPipeConstants.PIPE_PERCENTAGE_DECIMAL = 'percentagedecimal';
    DataPipeConstants.PIPE_TEMP_FAHRENHEIT = 'fahrenheit';
    DataPipeConstants.PIPE_TEMP_CELSIUS = 'celsius';
    DataPipeConstants.PIPE_TEMP_KELVIN = 'kelvin';
    DataPipeConstants.PIPE_MPH = 'mph';
    DataPipeConstants.PIPE_STRING_SLICE_FIFTY = 'slicefifty';
    DataPipeConstants.PIPE_STRING_SLICE_SEVENTY = 'sliceseventy';
    DataPipeConstants.PIPE_STRING_SLICE_HUNDRED = 'slicehundred';
    DataPipeConstants.PIPE_PASSWORD = 'password';
    return DataPipeConstants;
}());
export { DataPipeConstants };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1waXBlLmNvbnN0YW50cy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BsY3UvY29tbW9uLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL2NvbnN0YW50cy9kYXRhLXBpcGUuY29uc3RhbnRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVc7QUFDWDs7Ozs7Ozs7Ozs7O0dBWUc7QUFFSDtJQUFBO0lBOEJBLENBQUM7SUE1QjBCLDBCQUFRLEdBQUcsYUFBYSxDQUFDO0lBQ3pCLGdDQUFjLEdBQUcsUUFBUSxDQUFDO0lBQzFCLGlDQUFlLEdBQUcsVUFBVSxDQUFDO0lBQzdCLCtCQUFhLEdBQUcsaUJBQWlCLENBQUM7SUFDbEMsK0JBQWEsR0FBTSxpQkFBaUIsQ0FBQyxRQUFRLGNBQVcsQ0FBQztJQUN6RCxvQ0FBa0IsR0FBRyx5QkFBeUIsQ0FBQztJQUMvQywrQkFBYSxHQUFHLFNBQVMsQ0FBQztJQUMxQiwyQkFBUyxHQUFHLE1BQU0sQ0FBQztJQUNuQixnQ0FBYyxHQUFHLFdBQVcsQ0FBQztJQUM3QixpQ0FBZSxHQUFHLFlBQVksQ0FBQztJQUMvQiwrQkFBYSxHQUFHLFVBQVUsQ0FBQztJQUMzQixrQ0FBZ0IsR0FBRyxZQUFZLENBQUM7SUFDaEMsbUNBQWlCLEdBQUcsYUFBYSxDQUFDO0lBQ2xDLDRCQUFVLEdBQUcsT0FBTyxDQUFDO0lBQ3JCLDZCQUFXLEdBQUcsUUFBUSxDQUFDO0lBQ3ZCLGlDQUFlLEdBQUcsWUFBWSxDQUFDO0lBQy9CLHlDQUF1QixHQUFHLG1CQUFtQixDQUFDO0lBQzlDLHNDQUFvQixHQUFHLFlBQVksQ0FBQztJQUNwQyxtQ0FBaUIsR0FBRyxTQUFTLENBQUM7SUFDOUIsa0NBQWdCLEdBQUcsUUFBUSxDQUFDO0lBQzVCLDBCQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ2pCLHlDQUF1QixHQUFHLFlBQVksQ0FBQztJQUN2QywyQ0FBeUIsR0FBRyxjQUFjLENBQUM7SUFDM0MsMkNBQXlCLEdBQUcsY0FBYyxDQUFDO0lBQzNDLCtCQUFhLEdBQUcsVUFBVSxDQUFDO0lBSXRELHdCQUFDO0NBQUEsQUE5QkQsSUE4QkM7U0E5QlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGR5bmFtaWNcclxuLyoqXHJcbiAqIEBkeW5hbWljIG5lZWQgdGhpcyBiZWNhdXNlIHRoZXJlIGFyZSBzdGF0aWMgbWVtZWJlcnNcclxuICpcclxuICogU3RyaW5nIHRoYXQgcmVwcmVzZW50IHRoZSB0cmFuc2Zvcm1lZCBmb3JtYXQsIHVzZWRcclxuICogd2l0aCBEYXRhUGlwZXMuXHJcbiAqXHJcbiAqIEV4LlxyXG4gKiAvLyBjb25zdGFudHMgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBuZWVkIHRvIGJlIGFzc2lnbmVkXHJcbiAqIC8vIHRvIGEgbG9jYWwgcHJvcGVydHkgaW4gb3JkZXIgdG8gd29ya1xyXG4gKlxyXG4gKiBjb25zdCBkYXRlRm10OiBzdHJpbmcgPSBEYXRhUGlwZUNvbnN0YW50cy5EQVRFX0ZNVDtcclxuICogPHNwYW4+e3sgdmFsdWUgfCBkYXRhUGlwZXM6ZGF0ZUZtdCB9fTwvc3Bhbj5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRGF0YVBpcGVDb25zdGFudHMge1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREFURV9GTVQgPSAnZGQvTU1NL3l5eXknO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEQVRFX1NIT1JUREFURSA9ICdNL2QveXknO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEQVRFX01FRElVTURBVEUgPSAnTU1NIGQsIHknO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEQVRFX0ZVTExEQVRFID0gJ0VFRUUsIE1NTU0gZCwgeSc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERBVEVfVElNRV9GTVQgPSBgJHtEYXRhUGlwZUNvbnN0YW50cy5EQVRFX0ZNVH0gaGg6bW06c3NgO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEQVRFX1RJTUVfWk9ORV9GTVQgPSAnTU0vZGQveXl5eSBoaDptbTpzcyBhIHonO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEQVRFX0RBWV9USU1FID0gJ0VFRSBoIGEnO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBQSVBFX0RBVEUgPSAnZGF0ZSc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfU0hPUlREQVRFID0gJ3Nob3J0ZGF0ZSc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfTUVESVVNREFURSA9ICdtZWRpdW1kYXRlJztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9GVUxMREFURSA9ICdmdWxsZGF0ZSc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfREVDSU1BTF9UV08gPSAnZGVjaW1hbFR3byc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfREVDSU1BTF9GT1VSID0gJ2RlY2ltYWxmb3VyJztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9FUE9DSCA9ICdlcG9jaCc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfTlVNQkVSID0gJ251bWJlcic7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfUEVSQ0VOVEFHRSA9ICdwZXJjZW50YWdlJztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9QRVJDRU5UQUdFX0RFQ0lNQUwgPSAncGVyY2VudGFnZWRlY2ltYWwnO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBQSVBFX1RFTVBfRkFIUkVOSEVJVCA9ICdmYWhyZW5oZWl0JztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9URU1QX0NFTFNJVVMgPSAnY2Vsc2l1cyc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfVEVNUF9LRUxWSU4gPSAna2VsdmluJztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9NUEggPSAnbXBoJztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9TVFJJTkdfU0xJQ0VfRklGVFkgPSAnc2xpY2VmaWZ0eSc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBJUEVfU1RSSU5HX1NMSUNFX1NFVkVOVFkgPSAnc2xpY2VzZXZlbnR5JztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUElQRV9TVFJJTkdfU0xJQ0VfSFVORFJFRCA9ICdzbGljZWh1bmRyZWQnO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBQSVBFX1BBU1NXT1JEID0gJ3Bhc3N3b3JkJztcclxuXHJcblxyXG5cclxufVxyXG4iXX0=